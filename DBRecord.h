// DBRecord.h#pragma once/* A DBRecord stores a set of DBPairs and a "selected" bit. It supports operations to manipulate, test, read, and write its set of pairs.  The pairs are stored in a chunk list for efficiency.*/// Pre-declare types we need to refer tostruct Chunk;class DBPair;#include <iostream.h>class DBRecord {	public:		// Construct a record with no pairs and the selected bit off.	DBRecord();		// Release the owned memory pointed to by DBRecord	~DBRecord();		// Add the given pair to the record. Does not do any sort of	// duplicate detection. The strings continue to be owned by the caller--	// the DBRecord allocates memory for its own copies of the strings.	void AddPair(const char* attribute, const char* value);		// Accessors for the selected bit	bool Selected() const;	void SetSelected(bool newSelected);			// Set the record back so it is empty --	// remove all the pairs (releasing their memory) and clear the selected bit.	void Clear();			// Are all of the pairs of the receiver contained by	// the given record? The receiver is also known as the "criteria"	// in this context.	// "Contains" is as defined by the DBPair::Contains() --	// The attributes must match exactly, but the values	// need only be substrings. As a special case,	// a criteria string of exactly "*" matches anything.	// If the oneIsSufficient option is true, then not all of the pairs	// need be contained, just at least one.	bool ContainedBy(const DBRecord* container, bool oneIsSufficient = false) const;			/*	 Read or Write the attribute/value pairs of a record	 in ASCII form to a stream.	 The format is one pair per line. The attribute	 comes first and may not contain any whitespace.	 Then there is a single whitespace character followed	 by the value up to the end of the line.	 The end of the record is marked by a single blank line.	 For reading, the new pairs are added to any existing	 pairs in the record.	*/		void Write(ostream& out) const;	void Read(istream& in);		private:	// my private utility routines -- you can design your own	void EnsureHeadSpace();	// make it be the case that the head chunk has space	void FreeChunks();	bool ContainsPair(const DBPair& pair) const;		Chunk* chunk;	int length;	bool selected;};