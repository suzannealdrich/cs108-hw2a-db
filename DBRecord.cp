// DBRecord.cp#include "DBPair.h"#include "DBRecord.h"#include <string.h>#include <assert.h>const int CHUNK_SIZE = 2;struct Chunk {	DBPair pairs[CHUNK_SIZE];	Chunk* next;};DBRecord::DBRecord() {	chunk = NULL;	length = 0;	selected = false;}DBRecord::~DBRecord() {	FreeChunks();}void DBRecord::AddPair(const char* attribute, const char* value) {	EnsureHeadSpace();	int offset = (length % CHUNK_SIZE);	chunk->pairs[offset].SetAttributeValue(attribute, value);	length++;}bool DBRecord::Selected() const {	return selected;}void DBRecord::SetSelected(bool newSelected) {	selected = newSelected;}void DBRecord::Clear() {	FreeChunks();	length = 0;	selected = false;}bool DBRecord::ContainedBy(const DBRecord* container, bool oneIsSufficient) const {	Chunk* current = chunk;		int i, offset;	int bound = ((length-1) % CHUNK_SIZE)+1;	for (i=0, offset=0; i<length; i++, offset++) {		if (offset == bound) {			current = current->next;			bound = CHUNK_SIZE;			offset = 0;		}		if (container->ContainsPair(current->pairs[offset])) {			if (oneIsSufficient) return true;		} else {			if (!oneIsSufficient) return false;		}	}	return !oneIsSufficient;}void DBRecord::Write(ostream& out) const {	Chunk* current = chunk;		int i, offset;	int bound = ((length-1) % CHUNK_SIZE)+1;	for (i=0, offset=0; i<length; i++, offset++) {		if (offset == bound) {			current = current->next;			bound = CHUNK_SIZE;			offset = 0;		}				current->pairs[offset].Write(out);	}		out << endl;}void DBRecord::Read(istream& in) {	char ch;		int offset;	while (in.get(ch)) {				// read the char, false on EOF		if (ch=='\n') break;			// blank line, we're done				in.putback(ch);		EnsureHeadSpace();		offset = length % CHUNK_SIZE;		chunk->pairs[offset].Read(in);		length++;	}}void DBRecord::EnsureHeadSpace() {	if ((length % CHUNK_SIZE) == 0) {		Chunk* newChunk = new Chunk;		newChunk->next = chunk;		chunk = newChunk;	}}void DBRecord::FreeChunks() {	while (chunk != NULL) {		Chunk* oldHead = chunk;		chunk = chunk->next;		delete oldHead;	}}bool DBRecord::ContainsPair(const DBPair& pair) const {	Chunk* current = chunk;		int i, offset;	int bound = ((length-1) % CHUNK_SIZE)+1;	for (i=0, offset=0; i<length; i++, offset++) {		if (offset == bound) {			current = current->next;			bound = CHUNK_SIZE;			offset = 0;		}		if (current->pairs[offset].Contains(pair)) return true;	}	return false;}// When true, creates a main for basic testing#define TESTING 0#if TESTINGint main() {	DebugNewForgetLeaks();	// Clear the allocations which aren't ours	DBRecord *base = NEW DBRecord();	DBRecord *criteria = NEW DBRecord();	DBRecord *criteria2 = NEW DBRecord();	// Basic testing#define BASIC 1#if BASIC// Build three records in code// and do some basic exercise with them.// Lesson: it's handy to have test code which exercises the code// and which you can run with a single keystroke. In the cold,// cruel world, this sort of code won't be written for you -- you'll// need to invest the 3 minutes to write it yourself. Such code// pays dividends down the line. 			base->AddPair("title", "alien");	base->AddPair("actor", "sigourney weaver");	base->AddPair("actor", "yaphet kotto");	base->AddPair("actor", "harry dean stanton");	base->AddPair("year", "1979");		// Build a criteria for Alien 	criteria->AddPair("actor", "stanton");	criteria->AddPair("actor", "kotto");	criteria->AddPair("year", "1979");		// Repo-man	criteria2->AddPair("actor", "stanton");	criteria2->AddPair("actor", "estevez");		cout << "Base...\n";	base->Write(cout);		cout << "\n\nCriteria1...\n";	criteria->Write(cout);	cout << "Match...";	if (criteria->ContainedBy(base)) cout << "yes!\n";	else cout << "no!\n";		cout << "\n\nCriteria2...\n";	criteria2->Write(cout);	cout << "Match...";	if (criteria2->ContainedBy(base)) cout << "yes!\n";	else cout << "no!\n";	cout << "Match w/ one is sufficient...";	if (criteria2->ContainedBy(base, true)) cout << "yes!\n";	else cout << "no!\n";#else// Otherwise here's some interactive testing// read two records from stdin and print results	while (true) {		base->Clear();		criteria->Clear();		criteria2->Clear();				cout << "Enter base record:\n";		base->Read(cin);		base->Write(cout);				cout << "Enter criteria record:\n";		criteria->Read(cin);		criteria->Write(cout);				cout << "Base...\n";		base->Write(cout);				cout << "Criteria...\n";		criteria->Write(cout);			cout << "Match...";		if (criteria->ContainedBy(base)) cout << "ContainedBy:yes!\n";		else cout << "ContainedBy:no!\n";	}#endif		delete base;	delete criteria;	delete criteria2;		cout << "All done!\n";			DebugNewReportLeaks();	// Re-writes the "leaks.log" file	}#endif