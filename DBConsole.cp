// DBConsole.cp#include "DBRecord.h"#include "DB.h"#include "DBPair.h"#include <string.h>#include <fstream>const int BUFF_SIZE = MAX_STRING_LEN + 1;/* It is with a guilty conscience that I whipped up this command-line interface. It provides a lame human interface to the DB functionality. It picks out the commands "read," "select" etc. and maps each one to a DB call. You can use this interface to drive the DB interactively.  Gives an example of declaring C++ ojbect in the stack instead of in the heap -- its destructor gets called automatically.*/#define DB_CONSOLE 1#if DB_CONSOLEstatic void Console() {	DB* db = NEW DB;	char buff[BUFF_SIZE];		while (true) {		cout << "-----\n";		cout << db->Count() << " records\t" << db->SelectedCount() << " selected\n";		cout << "select [all], read, print [sel], delete {sel, uns, all}, clear >";		cin.getline(buff, BUFF_SIZE);				if (strstr(buff,"select")) {			bool all = (strstr(buff, "all") != NULL);						if (all) cout << "all pairs mode\n";			else cout << "any pair sufficient mode\n";						cout << "please enter criteria record ending with a blank line\n";			DBRecord criteria;	// temporary object on stack			criteria.Read(cin);						db->Select(&criteria, !all);		}		else if (strstr(buff,"print")) {			db->Write(cout, (strstr(buff, "sel") != NULL));		}		else if (strstr(buff,"read")) {			cout << "filename>";			cin.getline(buff, BUFF_SIZE);						if (strlen(buff)) {				ifstream in(buff);								db->Read(in);			}		}		else if (strstr(buff, "delete")) {			if (strstr(buff,"uns")) db->Delete(DB::delete_Unselected);			else if (strstr(buff,"sel")) db->Delete(DB::delete_Selected);			else if (strstr(buff,"all")) db->Delete(DB::delete_All);		}		else if (strstr(buff,"clear")) {			db->ClearSelection();		}		else if (strstr(buff,"quit")) break;	}		delete db;		// at this point, all the memory should have been freed		}int main() {	DebugNewForgetLeaks();	Console();	DebugNewReportLeaks();	return(0);}#endif