// DB.cp// The simple database class#include "DB.h"#include "DBRecord.h"#include "DBPair.h"#include <iostream.h>#include <string.h>#include <TArray.h>#include <TArrayIterator.h>#define TESTING_ARRAY 0#if TESTING_ARRAY/* Some throwaway code I used to experiment with the TArray interface. You can replace "int" as the element type with any other type, and it'll all work just the same.  Look in the book, or in LArray.cp for docs on the many array features.*/int main() {	TArray<int> ints;	// allocates an empty array of ints		// Basic use of InsertItemsAt() ....	// Count 1..20 and add those ints using  InsertItemsAt()	int i;	for (i=1; i<=20; i++) {		// This is the old fancy-but-cumbersome add element interface...		//ints.InsertItemsAt(		//	1,					// insert 1 copy		//	LArray::index_Last,	// insert it at the end (LArray::index_First is the alt)		//	i);				// the elem to insert -- type is correct (int)				// The new, simple add element interface...		ints.AddItem(i);	}		// Basic use of an iterator....	TArrayIterator<int> iterator(ints);	// starts at index 1 by default	while (iterator.Next(i)) {	// Copies into the lvalue -- type is correct (int)		cout << i << " ";				// ints.RemoveItemsAt(1, iterator.GetCurrentIndex()); // removes elems by index	}		ints.RemoveItemsAt(ints.GetCount(), 1);	// remove them all at once		cout << "\nlength:" << ints.GetCount() << endl;	/*		output:		1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 		length:0	*/		}#endifDB::DB() {}DB::~DB() {	TArrayIterator<DBRecord*> iterator(records);	DBRecord* current;	while (iterator.Next(current)) {		delete current;	}}void DB::Select(const DBRecord* criteria, bool oneIsSufficient) {	TArrayIterator<DBRecord*> iterator(records);	DBRecord* current;	while (iterator.Next(current)) {		if (criteria->ContainedBy(current, oneIsSufficient)) {			current->SetSelected(true);		}	}}int DB::Count() const {	return records.GetCount();}int DB::SelectedCount() const {	TArrayIterator<DBRecord*> iterator(records);	DBRecord* current;	int count = 0;	while (iterator.Next(current)) {		 if (current->Selected()) count++;	}	return count;}void DB::Delete(DeleteOption option) {	TArrayIterator<DBRecord*> iterator(records);	DBRecord* current;	while (iterator.Next(current)) {		switch (option) {		case delete_Selected:			if (!current->Selected()) continue;			break;		case delete_Unselected:			if (current->Selected()) continue;			break;		case delete_All: 			break;		}		delete current;		records.RemoveItemsAt(1, iterator.GetCurrentIndex());	}}void DB::ClearSelection() {	TArrayIterator<DBRecord*> iterator(records);	DBRecord* current;	while (iterator.Next(current)) {		current->SetSelected(false);		}}// Our file format is the DBR's one after another in a text file// with the end marked by the EOF.void DB::Read(istream& in) {	while (in.good() && in.peek() != EOF) {		DBRecord* record = NEW DBRecord();		record->Read(in);		records.AddItem(record);	}}void DB::Write(ostream& out, bool selectedOnly) const {	TArrayIterator<DBRecord*> iterator(records);	DBRecord* current;	while (iterator.Next(current)) {		 if (!selectedOnly || current->Selected()) current->Write(out);	}}